<?php
// $Id$

/**
 * @file
 * Task tracking
 */

define('TASK_TYPE_ACTIVE', 1);
define('TASK_TYPE_BLOCKED', 2);
define('TASK_TYPE_RESOLVED', 3);
define('TASK_TYPE_CLOSED', 4);

define('TASK_ACTIVE', 1);
define('TASK_WORKING_ON', 2);
define('TASK_BLOCKED', 3);
define('TASK_FEEDBACK', 4);
define('TASK_RESOLVED', 5);
define('TASK_REJECTED', 6);

/**
 * Implements hook_init().
 */
function task_init() {
  drupal_add_css(drupal_get_path('module', 'task') . '/task.css');
}

function task_state_type($type, $state = NULL) {
  static $state_types = array(
    TASK_TYPE_ACTIVE => array(
      TASK_ACTIVE,
      TASK_WORKING_ON,
    ),
    TASK_TYPE_BLOCKED => array(
      TASK_BLOCKED,
      // TASK_FEEDBACK,
    ),
    TASK_TYPE_RESOLVED => array(
      TASK_RESOLVED,
    ),
    TASK_TYPE_CLOSED => array(
      TASK_RESOLVED,
      TASK_REJECTED,
    ),
  );
  if ($state) {
    return in_array($state, $state_types[$type]);
  }
  return $state_types[$type];
}

function task_preprocess_node(&$variables) {
  $variables['theme_hook_suggestions'][] = 'node__' . $variables['view_mode'];
}

/**
 * Implements hook_entity_info_alter().
 *
 * Add our own view mode to nodes.
 */
function task_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['taskcard'] = array(
    'label' => t('Task card'),
  );
}

/**
 * Implements hook_field_ui_view_modes_tabs().
 */
function task_field_ui_view_modes_tabs() {
  $modes = array(
    'task' => array(
      'title' => t('Task'),
      'view modes' => array('taskcard'),
    ),
  );
  return $modes;
}

/**
 * Implements hook_theme().
 */
function task_theme() {
  return array(
    'node__taskcard' => array(
      'render element' => 'elements',
      'template' => 'node--taskcard',
    ),
  );
}

/**
 * Implements hook_cron_queue_info().
 */
function task_cron_queue_info() {
  $queues['task_update'] = array(
    'worker callback' => 'task_update_nid',
    'time' => 60,
  );
  return $queues;
}

/**
 * Implements hook_node_load().
 */
function task_node_load($nodes, $types) {
  $result = db_select('task_dirty')
    ->fields('task_dirty', array('nid'))
    ->condition('nid', array_keys($nodes))
    ->execute();

  $dirty = $result->fetchAllAssoc('nid');
  foreach ($nodes as $nid => $node) {
    // This is only for the sake of theming and like, anyone really interested
    // in the dirty status of a node should use task_is_dirty(), as it isn't
    // cached.
    $node->dirty = isset($dirty[$nid]);
  }
}

/**
 * Implements hook_node_presave().
 */
function task_node_presave($node) {
  if ($node->type == 'task') {
    // Always save a new revision.
    $node->revision = TRUE;
  }
}

/**
 * Implements hook_node_update().
 */
function task_node_update($node) {
  if ($node->type == 'task') {
    task_dirty($node);
  }
}

/*
 * This is the tricky part. We need to support different depth, and track how
 * deep we are. When a node is saved by a user we must process:
 *
 * The node itself,
 * It dependants, as they might be the next thing in the queue for the user.
 * And of course dirty the dependants of the dependants.
 *
 * That's two levels of processing, and 3 of dirtying.
 * In the queue runner, we just need to process one, and dirty its dependants.
 *
 * However, if node_save does the dirtying, which makes sense it has no idea of the depth..
 *
 * task_update could track it, as it would be called from within itself?
 * (assuming it does a node_save, which calls task_dirty). 
 */
function task_dirty($node, $set_recurse = NULL) {
  // Track recursion.
  static $recurse = TRUE;
  static $level = 0;
  $level += 1;

  if (is_bool($set_recurse)) {
    $recurse = $set_recurse;
  }

  if ($node) {
    task_set_dirty($node); // Mark dirty.
    // Only process recursively two levels.
    if ($recurse and $level < 3) {
      task_update($node); // Update the node right away, so direct dependants gets marked dirty.
    }
    else {
      task_queue_update($node); // Else queue for later processing.
    }
  }
  $level -= 1;
}

function task_update_nid($nid) {
  task_dirty(NULL, FALSE);
  $node = node_load($nid);
  task_update($node);
}


function task_queue_update($node) {
  // Add to queue
  $queue = DrupalQueue::get('task_update');
  $queue->createItem($node->nid);
}


function task_set_dirty($node) {
  if (is_object($node)) {
    $nid = $node->nid;
  }
  else {
    $nid = $node;
  }

  /*
   TODO: This throws exception, perhaps?
  db_insert('task_dirty')
    ->fields(array('nid' => $nid))
    ->execute();
  */
  db_query("INSERT IGNORE INTO {task_dirty} (nid) VALUES (:nid)", array(':nid' => $nid));
}

function task_set_undirty($node) {
  if (is_object($node)) {
    $nid = $node->nid;
  }
  else {
    $nid = $node;
  }

  db_delete('task_dirty')
    ->condition(array('nid', $nid))
    ->execute();
}

function task_is_dirty($node) {
  if (is_object($node)) {
    $nid = $node->nid;
  }
  else {
    $nid = $node;
  }
  return db_select('task_dirty')
    ->condition('nid', $nid)
    ->countQuery()
    ->execute()
    ->fetchField() > 0 ? TRUE : FALSE;
}


function task_update($node) {
  if (task_is_dirty($node)) {
    $field = field_info_field('state');
    $nids = task_get_dependee_nids($node);
    dpm('here');
    dpm($nids);
    $conditions = array(
                        array('type', 'node'),
                        array('entity_id', $nids, 'IN'),
                        array('value', task_state_type(TASK_TYPE_RESOLVED) , 'NOT IN')
                        );
    $t = field_attach_query($field['id'], $conditions, array('count' => TRUE));
    dpm($t);
    if ($t > 0) {
      dpm('b');
      if (task_state_type(TASK_TYPE_ACTIVE, $node->state[LANGUAGE_NONE][0]['value'])) {
        $node->state[LANGUAGE_NONE][0]['value'] = TASK_BLOCKED;
        node_save($node);
      }
    }
    else {
      dpm('a');
      if (task_state_type(TASK_TYPE_BLOCKED, $node->state[LANGUAGE_NONE][0]['value'])) {
        $node->state[LANGUAGE_NONE][0]['value'] = TASK_ACTIVE;
        node_save($node);
      }
    }
    task_set_undirty($node);
  }
}

/**
 * Get the nodes the given node depends on.
 */
function task_get_dependee_nodes($node) {
  return node_load_multiple(task_get_dependee_nids($node));
}

function task_get_dependee_nids($node) {
  return array_map('_task_nodereference_get_nid', $node->depends_on[LANGUAGE_NONE]);   
}

function _task_nodereference_get_nid($item) {
  return $item['nid'];
}

/**
 * Returns the nodes depended upon by the given node.
 */
function task_get_dependant_nodes($node) {
  return node_load_multiple(task_get_dependant_nids($node));
}

function task_get_dependant_nids($node) {
  $field = field_info_field('depends_on');
  $dependants = field_attach_query($field['id'], array(array('type', 'node'), array('nid', $node->nid)));
  return (isset($dependants['node']) ? array_keys($dependants['node']) : array());
}
